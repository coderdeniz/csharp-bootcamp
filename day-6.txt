RDBMS
--
Ýliþkisel veritabaný yönetim sistemi
ürünlerden bazýlarý: Oracle, SqlServer, MySql, Postgresql, access
kabul edilen standart: ANSI SQL
ürünlerin kendi standartlarý: PLSQL (oracle için), T-SQL (mssql için)
modelleme: normalizasyon modellemeyi destekler


NoSql
--
Veritabaný yönetim sistemi
ürünlerden bazýlarý: MongoDb,Firebase
not only sql: sadece sql deðil artým var anlamýna gelir
iliþkisellik söz konusu ama rdbms'deki kadar katý deðil

örnek: google web sitelerini index'lerken iþlenmemiþ çöplük gibi veriyi anlamlý hale getiriyor burada rdms kullanmasý söz konusu deðil onun yerine NoSql yapý kullanýyor.

örnek: loglama alt yapýlarýnda nosql kullanýlýyor ve genelde json þeklinde tutulur.


Normalizasyon
--
Datayý modelleme tekniðidir. Amaç veri kaçaklarýný engellemektir.
not: tablo ismi çoðul olurken sýnýf ismi tekil yazýlýr.
Tablolarda genelde Id sütunu yer alýr ve otomatik artan ilgili satýrý diðer satýrlardan
ayýrt etmemize yarar.

örnek: customers tablosu olsun id,name,city alaný verelim. city örnekleri: istanbul,ankara,izmir þeklinde olsun. Burada city alanýný yanlýþ yazabiliriz ya da 
tekrarlý verileri kullanabiliriz.(DRY Don't repeat yourself - kendini tekrar etme prensibine aykýrý hale gelmiþ olur.) City alaný sabit deðerlerden oluþtuðundan
city için baþka bir tablo oluþtururuz. Cities tablosundan aldýðýmýz id deðerlerini customers tablomuzda veririz. Burada normal tablonun id'si PK'dir ve PK olarak belirtilen
sütun ya da sütunlardaki satýrlar birbirinden farklý olmak zorundadýr. Bir sütundaki satýrlar farklý deðer almak zorunda olsun ama PK olmasýn istiyorsak UNIQUE olarak 
tanýmlayabiliriz. Diðer tablonun PK'sýný kendi tablomuzda iliþkisel veritabanýný kullanmak için FK(Foreign Key) olarak tanýmlarýz. Örnekteki CityId gibi..

Not: Normalizasyon'da en üst seviyeye getiremeyiz (over design). Belli baþlý durumlarý göz ardý etmemiz gerekecektir. Mesala name alaný ayný olan kullanýcýlar mevcut bunu 
engellemek için names tablosu yapabilirdik ama isimler sabit olmadýðý farklý isimler türetilebileceði için bu durumun altýndan kalkamayýz bu yüzden names alanýndaki tekrarlamayý
göz ardý edip, over design'den kurtuluruz.

Not: VS içinde SQL Server Object Explorer ile Sql'e ulaþabiliriz.


SQL
--
Group by: Grupladýktan sonra o grupla ilgili þart yazacaksak having ekini kullanmalýyýz.

Join: iki tabloyu birleþtirmek için join'lerden yararlanýrýz. ID'si diðer tabloda bulunan tabloyu join ile bir araya getirip detaylarýný çekebiliriz.

a- Inner join: iki tabloda da eþleþen datalarý getirir. Birinde var diðerinde yok ise getirmez.
b- Left/Right join: left için solda olup saðda olmayan right için ise tam tersi durumdaki kayýtlarý getiririz.

not: left/right join'lerde diðer tabloda olmayan kayýtlarý bulmak için id'si = null þartý koyabiliriz.

DTO: Data Transformation Object, product için category için ayrý class'lar yapýyorsak joinler için de DTO object'ler oluþturabiliriz. Ýki sýnýftaki istenen özellikleri DTO sýnýfýnda veririz.



C#
--

Bir sýnýf içerisinde baþka bir sýnýfý çaðýracaksan asla onu new'leme interface'i üzerinden çaðýr. Dependecy Injection
iþlemini gerçekleþtir. Mesala TC doðrulama Mernis Servisini direk manager içinde çaðýrma ayrý bir validate sýnýfý oluþtur ve onun içinde gerçekleþtir daha sonra validate sýnýfýnýn interface'sini asýl manager sýnýfýnda çaðýr.





